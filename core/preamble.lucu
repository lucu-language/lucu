##
# everything in this file is always in scope
##

##
# panics with message if the assertion is not met
# preferred to be used only for debugging
##
fun assert(all bool, msg str) {
	if all {
	} else { # fails
		panic(msg)
	}
}

##
# modulo operator
##
fun mod(dividend int, divisor int) int {
	dividend - ((dividend / divisor) * divisor)
}

##
# iterator
##
effect iter(`t) {
	fun next() `t
}

fun range(start usize, end usize) impl iter(usize) -> unit {
	mut n = start
	move {
		if n == end {
			break
		} else {
			n++
		}
	}
}

fun from(start usize) impl iter(usize) {
	mut n = start
	move { n++ }
}

##
# basic ranged for loop
##
fun for(it impl iter(`e) -> unit, fn impl consume(`e)) {
	try with it, fn loop {
		consume(next() as `e)
	}
}

##
# while loop
##
fun while(cond impl test, fn impl perform) {
	try with fn loop {
		if test() with cond {
			perform()
		} else {
			break
		}
	}
}

##
# until loop
##
fun until(cond impl test, fn impl perform) {
	try with fn loop {
		if test() with cond {
			break
		} else {
			perform()
		}
	}
}

##
# run
##
fun run(fn impl supply(`t)) `t {
	with fn {
		supply()
	}
}

##
# repeat loop
##
fun repeat(fn impl perform -> `t) `t {
	try with fn loop {
		perform()
	}
}

effect consume(`t) {
	fun consume(t `t)
}

effect test {
	fun test() bool
}

effect perform {
	fun perform()
}

effect supply(`t) {
	fun supply() `t
}

# TODO: && operator
fun and(a bool, b bool) bool {
	if a {
		b
	} else {
		false
	}
}

##
# exits the program and displays an error message
# preferred to be used only for debugging
##
fun panic(msg str) ! / srcloc {
	trace("panic: ")
	trace(msg)
	trace("\n")
	trap()
}

fun trap() ! / srcloc {
	trace("trapped at ")
	trace(source_location())
	trace("\n")
	trap_silent()
}

##
# exits the program and displays an error message
# marks code paths that aren't implemented yet
##
fun todo(msg str) ! / srcloc {
	trace("todo: ")
	trace(msg)
	trace("\n")
	trap()
}

fun internal() `t / srcloc {
	compile_error("internal function has no definition on specified target")
}

##
# the following functions have internal definitions
# these are not based on a specific target
##

fun compile_error(`msg str) ! / srcloc {
	internal()
}

##
# marks that a code path is unreachable
# this function should NEVER actually be called
# for displaying an error, &panic is preferred
##
fun unreachable() ! {
	internal()
}

##
# returns the length of a slice
##
fun len(slice []`elem) usize {
	internal()
}

##
# effect to get the location of the call in the source code
# has an internally defined global handler
# when used directly, it returns the location of the call to &source_location
# when used as an effect parameter inside a function, it returns the location of the caller
##
effect srcloc {
	fun source_location() str
}

impl srcloc {
	fun source_location() str {
		internal()
	}
}

##
# links to a dynamic library using an effect as a foreign interface
# &`effect MUST be annotated with @foreign,
# as it uses the data inside to determine the symbol names for the effect functions
##
effect foreign {
	fun impl_link(`lib str) impl `effect
	fun impl_asm(`assembly str, `constraints str, `sideeffects bool) impl `effect
	fun syscall(nr int, args [`N]int) int
}

##
# the following functions may have an internal definition based on the target
# they also have default implementations for unknown targets
##

##
# prints a debug message to the environment (usually the standard error)
# the message is printed exactly as it is, so concatinating strings is possible by calling &trace multiple times
##
fun trace(s str) {
	internal()
}

##
# function that ends execution of the entire program
# the way it ends execution depends on the target
# for instance, it could:
#  - end the process
#  - run a halt instruction
#  - throw an exception / interrupt
#  - spin forever
##
fun trap_silent() ! {
	internal()
}
