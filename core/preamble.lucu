##
# Everything in this file is always in scope
##

type never = !

##
# Panics with message if the assertion is not met,
# preferred to be used only for debugging.
##
fun assert(all bool, msg str) {
	if all {
	} else { # fails
		panic(msg)
	}
}

##
# Modulo operator
##
fun mod(dividend int, divisor int) int {
	dividend - ((dividend / divisor) * divisor)
}

##
# yield
##
effect yield(`t) {
	fun yield(t `t)
}

effect generator(`t) {
	fun generate() / yield(`t)
}

fun first(generate impl generator(`t)) `t / srcloc {
	try {
		generate.() with ({ t -> break t } as impl yield(`t) -> `t)
		panic("nothing was yielded")
	}
}

fun nth(num usize, generate impl generator(`t)) `t / srcloc {
	try {
		mut current usize = 0
		generate.() with ({
			t ->
			if current == num {
				break t
			} else {
				do current++
			}
		} as impl yield(`t) -> `t)
		panic("not enough was yielded")
	}
}

fun for(start usize, end usize, yield impl yield(usize)) {
	mut n = start
	try loop {
		if n == end {
			break
		} else {
			yield.(n++)
		}
	}
}

fun while(test impl test, body impl run) {
	try loop {
		if test.() {
			body.()
		} else {
			break
		}
	}
}

fun until(test impl test, body impl run) {
	try loop {
		if test.() {
			break
		} else {
			body.()
		}
	}
}

fun repeat(body impl run -> `t) `t {
	try loop {
		body.()
	}
}

effect test {
	fun test() bool
}

effect run {
	fun run()
}

effect fail {
	fun fail() !
}

# TODO: && operator
fun and(a bool, b bool) bool {
	if a {
		b
	} else {
		false
	}
}

##
# Exits the program and displays an error message,
# preferred to be used only for debugging.
##
fun panic(msg str) ! / srcloc {
	trace("panic: ")
	trace(msg)
	trace("\n")
	trap()
}

fun trap() ! / srcloc {
	trace("trapped at ")
	trace(source_location())
	trace("\n")
	trap_silent()
}

##
# Exits the program and displays an error message,
# marks code paths that aren't implemented yet.
##
fun todo(msg str) ! / srcloc {
	trace("todo: ")
	trace(msg)
	trace("\n")
	trap()
}

fun internal() `t {
	# internal()
	loop {}
}

##
# The following functions have internal definitions.
# These are not based on a specific target.
##

##
# Marks that a code path is unreachable.
# This function should NEVER actually be called!
# For displaying an error, &panic is preferred.
##
fun unreachable() ! {
	internal()
}

##
# Returns the length of a slice.
##
fun len(slice []const `elem) usize {
	internal()
}

##
# Creates a slice from a pointer and length.
##
fun raw_slice(ptr ^`t, len usize) []`t {
	internal()
}

##
# Effect to get the location of the call in the source code.
# When used directly, it returns the location of the call to &source_location.
# When used as an effect parameter inside a function, it returns the location of the caller.
##
effect srcloc {
	fun source_location() str
}

impl srcloc {
	fun source_location() str {
		internal()
	}
}

effect foreign {
	##
	# Links to a dynamic library using an effect as a foreign interface.
	# &`effect SHOULD be annotated with @foreign,
	# as it uses the data inside to determine the symbol names for the effect functions.
	##
	fun impl_link(`lib str) impl `effect

	fun impl_asm(`assembly str, `constraints str, `sideeffects bool) impl `effect

	fun syscall(nr int, args [`N]int) int
}

##
# The following functions may have an internal definition based on the target.
# They also have default implementations for unknown targets.
##

##
# Prints a debug message to the environment (usually the standard error).
# The message is printed exactly as it is, so concatinating strings is possible by calling &trace multiple times.
##
fun trace(s str) {
	internal()
}

##
# Function that ends execution of the entire program.
# The way it ends execution depends on the target.
# 
# For instance, it could:
#  - end the process
#  - run a halt instruction
#  - throw an exception / interrupt
#  - spin forever
##
fun trap_silent() ! {
	internal()
}
