//

import "../../ast"

exprs :: proc(exprs: ..ast.Expression) -> []ast.Expression {
  slice.reverse(exprs)
  return slice.clone(exprs)
}

exprs_append :: proc(exprs: []ast.Expression, expr: ast.Expression) -> []ast.Expression {
  slice := make([]ast.Expression, len(exprs) + 1)
  slice[0] = expr
  for i in 0..<len(exprs) {
    slice[i + 1] = exprs[i]
  }
  return slice
}

lambda_append :: proc(base: ast.Expression, lambda: ast.Expression) -> ast.Expression {
  if base.kind == .CALL || base.kind == .CALL_POINTER {
    ret := base
    ret.data.base = exprs_append(ret.data.base, lambda)
    return ret
  } else {
    return { .CALL, {base = exprs(base, lambda)} }
  }
}

//

## RULES

lucu // [dynamic]ast.Definition //
 -> definitions // this = _0 //
;

definitions // [dynamic]ast.Definition //
 ->
 -> definition                                             //            append(&this, _0) //
 -> definition_context "{" definitions "}"
 -> error                                  ";" definitions // this = _2                    //
 -> definition                             ";" definitions // this = _2; append(&this, _0) //
 -> definition_context "{" definitions "}" ";" definitions
;

definition_context // [dynamic]ast.Ident_Full //
 ->
 -> "(" ident_full_comma ")" "=>" // this = _1 //
;

definition // ast.Definition //
 -> definition_context definition_type   // this = _1; this.ctxt = _0[:] //
 -> definition_context definition_func   // this = _1; this.ctxt = _0[:] //
 -> definition_context definition_effect // this = _1; this.ctxt = _0[:] //
 -> definition_context definition_use    // this = _1; this.ctxt = _0[:] //
 -> definition_context definition_const
;

definition_const // ast.Definition //
 -> "const" partial_ident                    "=" expr
 -> "const" partial_ident ":" data_type_full "=" expr
 -> "const" partial_ident ":" data_type_full
;

definition_use // ast.Definition //
 -> "use" ident_full "{" definitions "}" // this = { nil, "", nil, ast.Definition_Use {_1}, ast.Definition_Impl { definition_use = _3[:] } } //
 -> "use" ident_full                     // this = { nil, "", nil, ast.Definition_Use {_1}, nil                                            } //
;

definition_effect // ast.Definition //
 -> "effect" partial_ident generics_defs "{" definitions "}" // this = { nil, _1, _2[:], ast.Definition_Effect {}, ast.Definition_Impl { definition_effect = _4[:] } } //
 -> "effect" partial_ident generics_defs                     // this = { nil, _1, _2[:], ast.Definition_Effect {}, nil                                               } //
;

definition_type // ast.Definition //
 -> "type" partial_ident generics_defs "=" data_type_full // this = { nil, _1, _2[:], ast.Definition_Type {}, ast.Definition_Impl { definition_type = _4 } } //
 -> "type" partial_ident generics_defs                    // this = { nil, _1, _2[:], ast.Definition_Type {}, nil                                          } //
;

definition_func // ast.Definition //
 -> "func" partial_ident func_sign body // this = { nil, _1, nil, _2, ast.Definition_Impl { definition_func = _3 } } //
 -> "func" partial_ident func_sign      // this = { nil, _1, nil, _2, nil                                          } //
;

func_sign // ast.Definition_Func //
 -> "(" params ")"                            // this = { _1[:], nil } //
 -> "(" params ")" "->" data_type_full_nofunc // this = { _1[:], _4  } //
;

# function parameter
param // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

# function parameters, may end with ","
params // [dynamic]ast.Param //
 ->
 -> param            //            append(&this, _0) //
 -> param "," params // this = _2; append(&this, _0) //
;

# generics of a type or effect
generics_defs // [dynamic]string //
 ->
 -> generic_ident generics_defs // this = _1; append(&this, _0) //
;

# identifier with optional package prefix
ident_package // ast.Ident_Full //
 -> generic_ident                   // this = { "", _0, {} } //
 -> partial_ident                   // this = { "", _0, {} } //
 -> partial_ident "." partial_ident // this = { _0, _2, {} } //
;

# identifier with optional package prefix and generics juxtaposition
ident_full // ast.Ident_Full //
 -> ident_package generics // this = _0; this.generics = _1[:] //
;

ident_full_comma // [dynamic]ast.Ident_Full //
 -> ident_full                      //            append(&this, _0) //
 -> ident_full ","                  //            append(&this, _0) //
 -> ident_full "," ident_full_comma // this = _2; append(&this, _0) //
;

# constant values
generics // [dynamic]ast.Generic //
 ->
 -> data_type   generics // this = _1; append(&this, _0) //
 -> int_literal generics // this = _1; append(&this, _0) //
 -> str_literal generics // this = _1; append(&this, _0) //
;

### TYPE RULES

# builtin type prefixes
type_prefixes // [dynamic]ast.Type_Prefix //
 -> type_prefix               //            append(&this, _0) //
 -> type_prefix type_prefixes // this = _1; append(&this, _0) //
;

type_prefix // ast.Type_Prefix //
 -> prefix_slice   // this = _0 //
 -> prefix_array   // this = _0 //
 -> prefix_pointer // this = _0 //
;

prefix_slice // ast.Type_Slice //
 -> "[" "]"
;

prefix_array // ast.Type_Array //
 -> "[" int_literal "]" // this = { _1  } //
 ->  "[" ident_full "]" // this = { _1  } //
 ->         "[" "_" "]" // this = { nil } //
;

prefix_pointer // ast.Type_Pointer //
 ->     "^" // this = { false } //
 -> "?" "^" // this = { true  } //
;

# param with optional name
member // ast.Param //
 -> data_type_full // this = { "", _0 } //
 -> named_member   // this = _0         //
;

named_member // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

members // [dynamic]ast.Param //
 ->
 -> member             //            append(&this, _0) //
 -> member "," members // this = _2; append(&this, _0) //
;

struct_members // [dynamic]ast.Param //
 ->
 -> named_member       //            append(&this, _0) //
 -> member "," members // this = _2; append(&this, _0) //
;

# type without prefixes
type_struct // ast.Type_Struct //
 -> "(" struct_members ")" // this = { _1[:] } //
;

type_head // ast.Type //
 -> "_"                    // this = { nil, nil } //
 -> type_struct            // this = { nil, _0  } //
 -> "(" data_type_full ")" // this = _1           //
;

# data type without generics
data_type // ast.Type //
 -> type_prefixes ident_package // this = { _0[:], _1 }                                                         //
 -> type_prefixes type_head     // inject_at(&_0, 0, .._1.prefix); this = { _0[:], _1.head }; delete(_1.prefix) //
 -> ident_package               // this = { nil, _0 }                                                           //
 -> type_head                   // this = _0                                                                    //
;

# data type with optional generics juxtaposition
data_type_full_nofunc // ast.Type //
 -> type_prefixes ident_full // this = { _0[:], _1 }           //
 -> type_prefixes type_head  // this = _1; this.prefix = _0[:] //
 -> ident_full               // this = { nil, _0 }             //
 -> type_head                // this = _0                      //
;

data_type_full // ast.Type //
 -> "func"
 -> "func"                               func_sign
 -> "func" "(" ident_full_comma ")" "=>" func_sign
 -> "func" "(" ident_full_comma ")"
 -> data_type_full_nofunc                          // this = _0 //
;

### EXPRESSION RULES

# param with optional type
lambda_param // ast.Param //
 -> option_ident                    // this = { _0, {} } //
 -> option_ident ":" data_type_full // this = { _0, _2 } //
;

lambda_param_nofunc // ast.Param //
 -> option_ident                           // this = { _0, {} } //
 -> option_ident ":" data_type_full_nofunc // this = { _0, _2 } //
;

option_ident // string //
 -> "_"
 -> partial_ident // this = _0 //
;

lambda_params // [dynamic]ast.Param //
 ->
 -> lambda_param_nofunc            //            append(&this, _0) //
 -> lambda_param "," lambda_params // this = _2; append(&this, _0) //
;

lambda // ast.Expression //
 -> "{" lambda_params "->" stmts_semi "}" // this = { .LAMBDA, {lambda = {_3[:], _1[:]}} } //
;

body // ast.Expression //
 -> "{" stmts_semi "}" // this = { .BODY, {base = _1[:]} } //
;

stmts_semi // [dynamic]ast.Expression //
 ->
 -> stmt_final          //            append(&this, _0) //
 -> stmt ";" stmts_semi // this = _2; append(&this, _0) //
;

stmts_semi_suffix // [dynamic]ast.Expression //
 ->
 -> ";" stmts_semi // this = _1 //
;

exprs // [dynamic]ast.Expression //
 ->
 -> expr                 //            append(&this, _0) //
 -> expr "," exprs // this = _2; append(&this, _0) //
;

named_expr // ast.Expression //
 -> partial_ident "=" expr // this = { .LET, {let = {exprs(_2), _0}} } //
;

member_expr // ast.Expression //
 -> named_expr // this = _0 //
 -> expr       // this = _0 //
;

member_exprs // [dynamic]ast.Expression //
 ->
 -> member_expr                  //            append(&this, _0) //
 -> member_expr "," member_exprs // this = _2; append(&this, _0) //
;

member_exprs_struct // [dynamic]ast.Expression //
 ->
 -> named_expr                   //            append(&this, _0) //
 -> member_expr "," member_exprs // this = _2; append(&this, _0) //
;

# non-recursive expression
loop_expr // ast.Expression //
 -> "loop" body // this = _1; this.kind = .LOOP //
;

cond_expr // ast.Expression //
 -> "if" expr_nolambda body               // this = { .IF_ELSE, {base = exprs(_1,_2)   } }        //
 -> "if" expr_nolambda body "else" body   // this = { .IF_ELSE, {base = exprs(_1,_2,_4)} }        //
 -> "if" expr_nolambda lambda             // this = { .IF_ELSE_UNWRAP, {base = exprs(_1,_2)   } } //
 -> "if" expr_nolambda lambda "else" body // this = { .IF_ELSE_UNWRAP, {base = exprs(_1,_2,_4)} } //
;

array_expr // ast.Expression //
 -> "[" exprs "]" // this = { .ARRAY,   {base = _1[:]} } //
;

struct_expr // ast.Expression //
 -> "(" member_exprs_struct ")" // this = { .STRUCT, {base = _1[:]} } //
;

expr_top // ast.Expression //
 -> lambda       // this = _0                              //
 -> body         // this = _0                              //
 -> loop_expr    // this = _0                              //
 -> cond_expr    // this = _0                              //
 -> array_expr   // this = _0                              //
 -> struct_expr  // this = _0                              //
 -> "(" expr ")" // this = _1                              //
 -> int_literal  // this = { .INT,   {int   = {nil, _0}} } //
 -> str_literal  // this = { .STR,   {str   = {nil, _0}} } //
 -> ident        // this = { .IDENT, {ident = {nil, _0}} } //
 -> "---"        // this = { .UNINIT, {} }                 //
;

# operator suffix
call // ast.Expression //
 -> expr_post     "(" member_exprs ")" // append(&_2, _0); this = { .CALL,         {base = _2[:]} } //
 -> expr_post "." "(" member_exprs ")" // append(&_3, _0); this = { .CALL_POINTER, {base = _3[:]} } //
;

expr_post // ast.Expression //
 -> expr_post "--"              // this = {  .UNARY_OP, {unnop  = {exprs(_0), .POST_DECREMENT}} } //
 -> expr_post "++"              // this = {  .UNARY_OP, {unnop  = {exprs(_0), .POST_INCREMENT}} } //
 -> expr_post "[" expr "]"      // this = { .BINARY_OP, {binop  = {exprs(_0, _2),      .INDEX}} } //
 -> expr_post "." partial_ident // this = {    .MEMBER, {member = {exprs(_0),_2              }} } //
 -> call                        // this = _0                                                      //
 -> expr_top                    // this = _0                                                      //
;

lambda_body // ast.Expression //
 -> lambda // this = _0                                          //
 -> body   // this = { .LAMBDA, {lambda = {_0.data.base, nil}} } //
;

expr_post_lambda // ast.Expression //
 -> expr_post            lambda_body // this = lambda_append(_0, _1)                     //
 -> expr_post_lambda     lambda_body // this = lambda_append(_0, _1)                     //
 -> expr_post        "." lambda_body // this = { .CALL_POINTER, {base = exprs(_0, _2)} } //
 -> expr_post_lambda "." lambda_body // this = { .CALL_POINTER, {base = exprs(_0, _2)} } //
;

# operator prefix
pre // ast.Unary_Op //
 -> "-" // this = .NEGATE    //
 -> "+" // this = .PLUS      //
 -> "&" // this = .REFERENCE //
;

expr_pre // ast.Expression //
 -> pre expr_pre // this = { .UNARY_OP, {unnop = {exprs(_1), _0}} } //
 -> expr_post    // this = _0                                       //
;

expr_pre_lambda // ast.Expression //
 -> pre expr_pre_lambda // this = { .UNARY_OP, {unnop = {exprs(_1), _0}} } //
 -> expr_post_lambda    // this = _0                                       //
;

# keyword prefix
expr_keyword // ast.Expression //
 -> "@sizeof"  data_type_full // this = { .SIZE_OF,  {sizeof  = {nil, _1}} }        //
 -> "@alignof" data_type_full // this = { .ALIGN_OF, {alignof = {nil, _1}} }        //
 -> "cast" expr_keyword       // this = { .UNARY_OP, {unnop = {exprs(_1), .CAST}} } //
 -> expr_pre                  // this = _0                                          //
;

expr_keyword_lambda // ast.Expression //
 -> "cast" expr_keyword_lambda // this = { .UNARY_OP, {unnop = {exprs(_1), .CAST}} } //
 -> expr_pre_lambda            // this = _0                                          //
;

# "as" keyword (needs to bind less close than "cast")
expr_typed // ast.Expression //
 -> expr_typed "as" data_type_full // this = { .AS, {as = {exprs(_0), _2}} } //
 -> expr_keyword                   // this = _0                              //
;

expr_typed_lambda // ast.Expression //
 -> expr_typed_lambda "as" data_type_full // this = { .AS, {as = {exprs(_0), _2}} } //
 -> expr_keyword_lambda                   // this = _0                              //
;

# multiplicative operators
mul // ast.Binary_Op //
 -> "*" // this = .MULTIPLY //
 -> "/" // this = .DIVIDE   //
 -> "%" // this = .MODULUS  //
;

expr_mul // ast.Expression //
 -> expr_mul mul expr_typed // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_typed              // this = _0                                            //
;

expr_mul_lambda // ast.Expression //
 -> expr_mul_lambda mul expr_typed        // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_mul        mul expr_typed_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_mul_lambda mul expr_typed_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_typed_lambda                     // this = _0                                            //
;

# additive operators
add // ast.Binary_Op //
 -> "+" // this = .ADD      //
 -> "-" // this = .SUBTRACT //
;

expr_add // ast.Expression //
 -> expr_add add expr_mul // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } // 
 -> expr_mul              // this = _0                                            //
;

expr_add_lambda // ast.Expression //
 -> expr_add_lambda add expr_mul        // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_add        add expr_mul_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_add_lambda add expr_mul_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_mul_lambda                     // this = _0                                            //
;
 
# comparison operators
cmp // ast.Binary_Op //
 -> ">"  // this = .GREATER        //
 -> "<"  // this = .LESS           //
 -> ">=" // this = .GREATER_EQUALS //
 -> "<=" // this = .LESS_EQUALS    //
;

expr_cmp // ast.Expression //
 -> expr_cmp cmp expr_add // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } // 
 -> expr_add              // this = _0                                            //
;

expr_cmp_lambda // ast.Expression //
 -> expr_cmp_lambda cmp expr_add        // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_cmp        cmp expr_add_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_cmp_lambda cmp expr_add_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_add_lambda                     // this = _0                                            //
;

# equality operators
eq // ast.Binary_Op //
 -> "==" // this = .EQUALS     //
 -> "!=" // this = .NOT_EQUALS //
;

expr_eq // ast.Expression //
 -> expr_eq eq expr_cmp // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } // 
 -> expr_cmp            // this = _0                                            //
;

expr_eq_lambda // ast.Expression //
 -> expr_eq_lambda eq expr_cmp        // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_eq        eq expr_cmp_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_eq_lambda eq expr_cmp_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_cmp_lambda                   // this = _0                                            //
;

# range operators
range // ast.Binary_Op //
 -> ".." // this = .RANGE //
;

expr_range // ast.Expression //
 -> expr_range range expr_eq // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_eq                  // this = _0                                            //
;

expr_range_lambda // ast.Expression //
 -> expr_range_lambda range expr_eq        // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_range        range expr_eq_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_range_lambda range expr_eq_lambda // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> expr_eq_lambda                         // this = _0                                            //
;

# expression with no lambda call syntax
expr_nolambda // ast.Expression //
 -> expr_range // this = _0 //
;

# expression with at least one lambda call syntax
expr_lambda // ast.Expression //
 -> expr_range_lambda // this = _0 //
;

# any expression
expr // ast.Expression //
 -> expr_nolambda // this = _0 //
 -> expr_lambda   // this = _0 //
;

# assign operators
stmt_ass // ast.Expression //
 -> expr "=" stmt_ass // this = { .BINARY_OP, {binop = {exprs(_0, _2), .ASSIGN}} } //
 -> expr              // this = _0                                                 //
;

ass_op // ast.Binary_Op //
 -> "+=" // this = .ADD_ASSIGN //
 -> "-=" // this = .SUB_ASSIGN //
 -> "/=" // this = .DIV_ASSIGN //
 -> "*=" // this = .MUL_ASSIGN //
 -> "%=" // this = .MOD_ASSIGN //
;

stmt_ass_op // ast.Expression //
 -> expr ass_op stmt_ass // this = { .BINARY_OP, {binop = {exprs(_0, _2), _1}} } //
 -> stmt_ass             // this = _0                                            //
;

# statement
stmt // ast.Expression //
 -> "let" option_ident ":" data_type_full "=" stmt_ass // this = { .LET, {let = {exprs({ .AS, {as = {exprs(_5), _3}} }), _1 }} } //
 -> "let" option_ident                    "=" stmt_ass // this = { .LET, {let = {exprs(                         _3    ), _1 }} } //
 -> "mut" option_ident ":" data_type_full "=" stmt_ass // this = { .MUT, {let = {exprs({ .AS, {as = {exprs(_5), _3}} }), _1 }} } //
 -> "mut" option_ident                    "=" stmt_ass // this = { .MUT, {let = {exprs(                         _3    ), _1 }} } //
 ->                                      "do" expr     // this = { .UNARY_OP, {unnop = {exprs(_1), .DO}} }                       //
 ->                                   "break" expr     // this = { .BREAK,    {base  =  exprs(_1)      } }                       //
 ->                                   "break"          // this = { .BREAK,    {base  =  nil            } }                       //
 -> stmt_ass_op                                        // this = _0                                                              //
;

# final statement of a body
stmt_final // ast.Expression //
 -> "use" lambda_params "<-" expr        stmts_semi_suffix // this = lambda_append(_3, { .LAMBDA, {lambda = {_4[:], _1[:]}} }) //
 -> "use" ident_full lambda              stmts_semi_suffix
 -> "use" ident_full "{" definitions "}" stmts_semi_suffix
 -> stmt                                                   // this = _0                                                        //
;

## LEXEMES

ident // string //
 -> generic_ident // this = _0 //
 -> partial_ident // this = _0 //
;

generic_ident // string // ;
partial_ident // string // ;

int_literal // u64 // ;

str_literal // string // ;
