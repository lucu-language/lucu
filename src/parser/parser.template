package generated

import "core:slice"
import "core:fmt"
import "core:os"
import "core:strings"
import "core:crypto/hash"

//preamble
//l ${preamble}

//e
Symbol :: enum { EOF, ERR } //d
//l Symbol :: enum {
//symbol
  //w  ${symbol.enum},
//e
//w  }

SymbolValue :: struct #raw_union {} //d
//l SymbolValue :: struct #raw_union {
//symbol
  //symbol.type
    //w  ${symbol.enum}: ${symbol.type},
  //e
//e
//w  }

Token :: struct { symbol: Symbol, value: SymbolValue }

token_value_string :: proc(token: Token) -> string {
  sb: strings.Builder
  #partial switch token.symbol {
  //symbol
  //symbol.type
    //l case .${symbol.enum}: fmt.sbprintf(&sb, "%v", token.value.${symbol.enum})
  //e
  //e
  }
  return strings.to_string(sb)
}

token_color :: proc(token: Token) -> [3]u8 {
  typ: string
  #partial switch token.symbol {
  //symbol
  //symbol.type
    //l case .${symbol.enum}: typ = "${symbol.type}"
  //e
  //e
    case: return { 0x83, 0x83, 0x83 }
  }

  buf: [hash.MAX_DIGEST_SIZE]u8
  hash.hash_string_to_buffer(.SHA512_256, typ, buf[:])

  return { buf[0], buf[1], buf[2] }
}

symbol_from_literal :: proc(literal: string) -> Symbol {
  switch literal {
  //symbol
  //symbol.literal
    //l case "${symbol.name}": return .${symbol.enum}
  //e
  //e
    case: return .ERR
  }
}

symbol_name :: proc(symbol: Symbol) -> string {
  switch symbol {
    case .EOF: return "EOF" //d
    case .ERR: return "ERR" //d
  //symbol
    //l case .${symbol.enum}: return "${symbol.name}"
  //e
  }
  return ""
}

symbol_follows_semicolon :: proc(symbol: Symbol) -> bool {
  #partial switch symbol {
  //symbol
  //symbol.name.";"
    //l case
  //symbol.follow
    //w  .${follow.enum}
    //s ,
  //e
    //w : return true
  //e
  //e
    case: return false
  }
}

symbol_precedes_semicolon :: proc(symbol: Symbol) -> bool {
  #partial switch symbol {
  //symbol
  //symbol.follow.name.";"
    //l case .${symbol.enum}: return true
  //e
  //e
    case: return false
  }
}

State :: struct { symbol: Symbol, value: SymbolValue, state: int }
Parser :: struct { stack: [dynamic]Token, shifted: #soa[dynamic]State, state: int }

Result :: enum {
  OK,
  ACCEPT,
  FAIL,
}

peek :: proc(a: []Token) -> Symbol {
  i := len(a) - 1
  if i >= 0 do return a[i].symbol
  return .EOF
}

parser_init :: proc(tokens: [dynamic]Token) -> Parser {
  stack := tokens
  slice.reverse(stack[:])
  return { stack, {}, 0 }
}

parser_delete :: proc(parser: Parser) {
  delete(parser.stack)
  delete(parser.shifted)
}

parser_will_shift :: proc(parser: ^Parser) -> bool {
  symbol := peek(parser.stack[:])

  switch parser.state {
  //state
    //l case ${state.index}:
    case 0: //d
      #partial switch symbol {
      //state.lookahead lah
        //l case
        //lah.symbol
          //w  .${symbol.enum}
          //s ,
        //e
        //w :
        //lah.accept
          //l return false
        //e
        //lah.shift
          //l return true
        //e
        //lah.reduce
          //l return false
        //e
      //e
      }
  //e
  }

  if symbol == .ERR {
    return len(parser.shifted) > 0
  } else if len(parser.shifted) != 0 && parser.shifted[len(parser.shifted) - 1].symbol == .ERR {
    return len(parser.stack) > 0
  } else {
    return false
  }
}

parser_step :: proc(parser: ^Parser) -> Result {

  shift :: proc(parser: ^Parser, new_state: int) {
    val := pop_safe(&parser.stack) or_else Token{ .EOF, {} }
    append_soa(&parser.shifted, State { val.symbol, val.value, parser.state })
    parser.state = new_state
  }

  reduce :: proc(parser: ^Parser, f: $T/proc(children: [$N]SymbolValue) -> Token) {
    vals: [N]SymbolValue = ---
    when N > 0 {
      _, values, _ := soa_unzip(parser.shifted[:])
      copy_slice(vals[:], values[len(values) - N:])
      parser.state = parser.shifted[len(parser.shifted) - N].state
      resize_soa(&parser.shifted, len(parser.shifted) - N)
    }
    append(&parser.stack, f(vals))
  }

  symbol := peek(parser.stack[:])
  switch parser.state {
  //state
    //l case ${state.index}:
    case 0: //d
      #partial switch symbol {
      //state.lookahead lah
        //l case
        //lah.symbol
          //w  .${symbol.enum}
          //s ,
        //e
        //w :
        //lah.accept
          //l return .ACCEPT
        //e
        //lah.shift
          //l shift(parser, ${shift})
          //l return .OK
        //e
        //lah.reduce
          //l reduce(parser,
          //l   proc (children: [${reduce.rhs.length}]SymbolValue) -> Token {
          //l     ret: SymbolValue
          //reduce.lhs.type
            //w ; this: ${type}
            //reduce.rhs child index
              //child.type
                //w ; _${index} := children[${index}].${child.enum}
              //e
            //e
            //reduce.code
              //l ${code}
            //e
            //l   ret.${reduce.lhs.enum} = this
          //e
          //w ; return { .${reduce.lhs.enum}, ret }
          //l   })
          //l return .OK
        //e
      //e
      }
  //e
  }

  if symbol == .ERR {
    if len(parser.shifted) == 0 do return .FAIL
    parser.state = parser.shifted[len(parser.shifted) - 1].state
    resize_soa(&parser.shifted, len(parser.shifted) - 1)
  } else if len(parser.shifted) != 0 && parser.shifted[len(parser.shifted) - 1].symbol == .ERR {
    if len(parser.stack) == 0 do return .FAIL
    pop(&parser.stack)
  } else {
    append(&parser.stack, Token{ .ERR, {} })
  }

  return .OK
}

parse :: proc(tokens: [dynamic]Token) -> bool { //d
//l parse :: proc(tokens: [dynamic]Token) -> (
//rule.0.lhs.type
  //w ${type},
//e
//w bool) {
  parser := parser_init(tokens)
  state := Result.OK
  for state == .OK do state = parser_step(&parser)

  if state == .ACCEPT {
    return true //d
    //l return
    //rule.0.lhs.type
      //w  parser.shifted[0].value.${rule.0.lhs.enum},
    //e
    //w  true
  } else {
    return false //d
    //l return
    //rule.0.lhs.type
      //w {},
    //e
    //w  false
  }
}
