effect text(`str) {
	
	type codepoint

	fun bytes(s `str)      []const u8
	fun codepoints(s `str) impl iter(codepoint) -> unit
	fun graphemes(s `str)  impl iter(`str)      -> unit

	fun encoding() impl encoding -> unit

	fun from_raw_bytes(s []const u8) `str

}

type unicode_rune = #distinct u32

effect encoding {
	fun  read_unicode()    unicode_rune  / iter(u8)
	fun write_unicode(rune unicode_rune) / sink(u8)
}

fun unicode_runes(s `str) impl iter(unicode_rune) -> unit / text(`str) {
	let iter = iter_slice(bytes(s))
	move {
		use iter
		try with encoding() {
			read_unicode()
		} else {
			panic("string is incorrectly encoded")
		}
	}
}

fun from_unicode(runes impl iter(unicode_rune) -> unit) `str / text(`str) buf(u8) {
	let start = buf_len()

	for(runes) {
		rune ->

		use sink_buffer()
		try with encoding() {
			write_unicode(rune)
		} else {
			panic("encoding has no representation for unicode character")
		}
	}

	let bytes = buf_slice()[start..]
	from_raw_bytes(bytes)
}
