//

import "../../ast"

//

## RULES

lucu // [dynamic]ast.Definition //
  ->
  -> error      ";" lucu // this = _2                    //
  -> definition ";" lucu // this = _2; append(&this, _0) //
;

definition // ast.Definition //
 -> definition_type // this = _0 //
 -> definition_func // this = _0 //
;

definition_type // ast.Definition //
 -> "type" partial_ident generics_defs "=" data_type_full // this = { _1, _2[:], ast.Definition_Type {}, ast.Definition_Impl { definition_type = _4 } } //
 -> "type" partial_ident generics_defs                    // this = { _1, _2[:], ast.Definition_Type {}, nil                                          } //
;

definition_func // ast.Definition //
 -> "func" partial_ident func_sign body // this = { _1, nil, _2, ast.Definition_Impl { definition_func = _3 } } //
 -> "func" partial_ident func_sign      // this = { _1, nil, _2, nil                                          } //
;

type_sign // ast.Definition_Type //
 ->
;

func_sign // ast.Definition_Func //
 -> "(" params ")"                     // this = { _1[:], nil } //
 -> "(" params ")" "->" data_type_full // this = { _1[:], _4  } //
;

body // ast.Body //
 -> "{" "}"
;

# function parameter
param // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

# function parameters, may end with ","
params // [dynamic]ast.Param //
 ->
 -> param            //            append(&this, _0) //
 -> param "," params // this = _2; append(&this, _0) //
;

# generics of a type or effect
generics_defs // [dynamic]string //
 ->
 -> generic_ident generics_defs // this = _1; append(&this, _0) //
;

# identifier with optional package prefix
ident_package // ast.Ident_Full //
 -> ident                           // this = { "", _0, {} } //
 -> partial_ident "." partial_ident // this = { _0, _2, {} } //
;

# identifier with optional package prefix and generics juxtaposition
ident_full // ast.Ident_Full //
 -> ident_package generics // this = _0; this.generics = _1[:] //
;

# constant values
generics // [dynamic]ast.Generic //
 ->
 -> data_type   generics // this = _1; append(&this, _0) //
 -> int_literal generics // this = _1; append(&this, _0) //
 -> str_literal generics // this = _1; append(&this, _0) //
;

# builtin type prefixes
type_prefixes // [dynamic]ast.Type_Prefix //
 -> type_prefix               //            append(&this, _0) //
 -> type_prefix type_prefixes // this = _1; append(&this, _0) //
;

type_prefix // ast.Type_Prefix //
 -> prefix_slice   // this = _0 //
 -> prefix_array   // this = _0 //
 -> prefix_pointer // this = _0 //
;

prefix_slice // ast.Type_Slice //
 -> "[" "]"
;

prefix_array // ast.Type_Array //
 -> "[" int_literal "]" // this = { _1  } //
 ->  "[" ident_full "]" // this = { _1  } //
 ->         "[" "_" "]" // this = { nil } //
;

prefix_pointer // ast.Type_Pointer //
 ->     "^" // this = { false } //
 -> "?" "^" // this = { true  } //
;

# struct members
named_member // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

member // ast.Param //
 -> data_type_full // this = { "", _0 } //
 -> named_member   // this = _0         //
;

members // [dynamic]ast.Param //
 ->
 -> member             //            append(&this, _0) //
 -> member "," members // this = _2; append(&this, _0) //
;

struct_members // [dynamic]ast.Param //
 ->
 -> named_member       //            append(&this, _0) //
 -> member "," members // this = _2; append(&this, _0) //
;

# type without prefixes
type_struct // ast.Type_Struct //
 -> "(" struct_members ")" // this = { _1[:] } //
;

type_head // ast.Type //
 -> "_"                    // this = { nil, nil } //
 -> type_struct            // this = { nil, _0  } //
 -> "(" data_type_full ")" // this = _1           //
;

# data type without generics
data_type // ast.Type //
 -> type_prefixes ident_package // this = { _0[:], _1 }                                                         //
 -> type_prefixes type_head     // inject_at(&_0, 0, .._1.prefix); this = { _0[:], _1.head }; delete(_1.prefix) //
 -> ident_package               // this = { nil, _0 }                                                           //
 -> type_head                   // this = _0                                                                    //
;

# data type with optional generics juxtaposition
data_type_full // ast.Type //
 -> type_prefixes ident_full // this = { _0[:], _1 }           //
 -> type_prefixes type_head  // this = _1; this.prefix = _0[:] //
 -> ident_full               // this = { nil, _0 }             //
 -> type_head                // this = _0                      //
;

## LEXEMES

ident // string //
 -> generic_ident // this = _0 //
 -> partial_ident // this = _0 //
;

generic_ident // string // ;
partial_ident // string // ;

int_literal // u64 // ;

str_literal // string // ;
