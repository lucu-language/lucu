type unit = ()
type never

# Largest unsigned integer that can fit in a general register.
type uint
# Unsigned integer that can fit the largest consecutive memory size.
type usize
# Unsigned integer that can fit a pointer.
type uptr

type u8
type u16
type u32
type u64

# Signed equivalent of &uint. 
type int
# Signed equivalent of &usize.
type isize
# Signed equivalent of &uptr.
type iptr

type i8
type i16
type i32
type i64

# Largest floating point number that can fit in a general register.
type float

type f16
type f32
type f64

type bool
type str
type char

const unit  = ()
const true  = 0 == 0
const false = 0 != 0

type Body 'e 't = func ('e) => () -> 't

(SrcLoc) => {
	##
	# Panics with message if the assertion is not met.
	##
	func assert(all: bool, msg: str) {
		if all {
		} else { # fails
			panic(msg)
		}
	}
	##
	# Exits the program and displays an error message.
	##
	func panic(msg: str) -> never {
		trace("panic: ")
		trace(msg)
		trace("\n")
		trap()
	}
	##
	# Exits the program and displays an error message,
	# marks code paths that aren't implemented yet.
	##
	func todo(msg: str) -> never {
		trace("todo: ")
		trace(msg)
		trace("\n")
		trap()
	}
	##
	# Exits the program without an error message,
	# only displays the source location it errored at.
	##
	func trap() -> never {
		trace("trapped at ")
		trace(location())
		trace("\n")
		trap_silent()
	}
}

## MARKER EFFECTS ##

effect Clone 't {
	func clone(t: ^'t) -> 't
}

##
# Any type 't where Copy 't is defined
# will use copy semantics instead of move semantcs.
#
# The naming convention for copy types is littlecase,
# where the convention for non-copy types is PascalCase.
##
(Clone 't) => effect Copy 't {}

## OPERATOR EFFECTS ##

effect BinOp 'op { const _: string = 'op }
handle BinOp "+" {}
handle BinOp "-" {}
handle BinOp "*" {}
handle BinOp "/" {}
handle BinOp "%" {}

(BinOp 'op) =>
effect Infix 'lhs 'op 'rhs {
	type Output
	func infix(lhs: 'lhs, rhs: 'rhs) -> Output
}

(BinOp 'op) =>
effect Assign 'lhs 'op 'rhs {
	func assign(lhs: ^'lhs, rhs: 'rhs)
}

##
# Defines the infix operator using the assignment operator.
# This way you only have to define the assignment operator for copy types.
##
(Copy 'lhs, Assign 'lhs 'op 'rhs) =>
handle Infix 'lhs 'op 'rhs {
	type Output = 'lhs
	func infix(lhs: 'lhs, rhs: 'rhs) -> Output {
		mut copy = lhs
		assign(&copy, rhs)
		copy
	}
}
 
## NUMBER EFFECTS ##

effect Num 't {
	const ZERO: 't
	const ONE: 't

	handle Assign 't "+" 't
	handle Assign 't "-" 't
	handle Assign 't "*" 't
	handle Assign 't "/" 't

	handle Assign 't "%" 't {
		dividend, divisor ->
		dividend - ((dividend / divisor) * divisor)
	}
}

(Num 't) => effect Signed 't {}
(Num 't) => effect  Float 't {}

handle Signed int   {}
handle Signed isize {}
handle Signed iptr  {}
handle Signed i8    {}
handle Signed i16   {}
handle Signed i32   {}
handle Signed i64   {}

handle Signed float {}
handle Signed f16   {}
handle Signed f32   {}
handle Signed f64   {}

handle Float float {}
handle Float f16   {}
handle Float f32   {}
handle Float f64   {}

handle Copy uint  {}
handle Copy usize {}
handle Copy uptr  {}
handle Copy u8    {}
handle Copy u16   {}
handle Copy u32   {}
handle Copy u64   {}

handle Copy int   {}
handle Copy isize {}
handle Copy iptr  {}
handle Copy i8    {}
handle Copy i16   {}
handle Copy i32   {}
handle Copy i64   {}

handle Copy float {}
handle Copy f16   {}
handle Copy f32   {}
handle Copy f64   {}

handle Copy unit  {}
handle Copy never {}
handle Copy bool  {}
handle Copy char  {}

## THE FOLLOWING DECLARATIONS HAVE INTERNAL DEFINITIONS ##

handle Num uint
handle Num usize
handle Num uptr
handle Num u8
handle Num u16
handle Num u32
handle Num u64

handle Num int
handle Num isize
handle Num iptr
handle Num i8
handle Num i16
handle Num i32
handle Num i64

handle Num float
handle Num f16
handle Num f32
handle Num f64

handle Clone uint
handle Clone usize
handle Clone uptr
handle Clone u8
handle Clone u16
handle Clone u32
handle Clone u64

handle Clone int
handle Clone isize
handle Clone iptr
handle Clone i8
handle Clone i16
handle Clone i32
handle Clone i64

handle Clone float
handle Clone f16
handle Clone f32
handle Clone f64

handle Clone unit
handle Clone never
handle Clone bool
handle Clone char

##
# Loops the body function indefinitely.
##
func loop(body: func) -> never

##
# Marks that a code path is unreachable.
# This function should NEVER actually be called!
# For displaying an error, &panic is preferred.
##
func unreachable() -> never

##
# Returns the length of a slice.
##
func len(slice: []'t) -> usize

##
# Creates a slice from a pointer and length.
##
func raw_slice(ptr: ^'t, len: usize) -> []'t

##
# Effect to get the location of the call in the source code.
# When handled directly, it returns the location of the call to &source_location.
# When handled as an effect parameter inside a function, it returns the location of the caller.
##
effect SrcLoc {
	func location() -> str
}

handle SrcLoc

##
# Prints a debug message to the environment (usually the standard error).
# The message is printed exactly as it is, so concatinating strings is possible by calling &trace multiple times.
#
# On unsupported targets, this does nothing.
##
func trace(s: str)

##
# Function that ends execution of the entire program.
# The way it ends execution depends on the target.
# 
# For instance, it could:
#  - end the process
#  - run a halt instruction
#  - throw an exception / interrupt
#  - spin forever
#
# On unsupported targets, this spins forever.
##
func trap_silent() -> never
