effect Yield[T] = {
	fun yield(t: T)
}

with Loc
fun first[T] { body with Yield[T] }: T = {
	try {
		body
		panic("nothing was yielded")
	} with Yield[T] {
		t => break t
	}
}

with Loc
fun nth[T] { body with Yield[T] }: T = {
	let mut current: usize = 0
	try {
		body
		panic("not enough was yielded")
	} with Yield[T] {
		t =>
		if current == num {
			break t
		} else {
			do current++
		}
	}
}

with Loc
fun last[T] { body with Yield[T] }: T = {
	let mut current: T = ---
	let mut yielded = false
	try body with Yield[T] {
		t =>
		current = t
		yielded = true
	}
	if yielded {
		current
	} else {
		panic("nothing was yielded")
	}
}

effect Generator[T] = {
	type Item

	with Yield[Item]
	fun generate(t: T)
}

with Generator[T]
fun for[T](t: T) { body(e: Item) } = {
	try generate(t) with Yield[Item] { e => body(e) }
}

type Range = struct (from: usize, to: usize)

default Generator[Range] {
	type Item = usize

	with Yield[usize]
	fun generate(self: Range) = {
		let mut n = self.start
		loop {
			if n == self.end {
				break
			} else {
				yield(n)
			}
		}
	}
}

default[E] Generator[[]E] {
	type Item = E

	with Yield[E]
	fun generate(self: []E) = {
		for(0..len(self)) { i => yield(self[i]) }
	}
}

default[N: usize, E] Generator[[N]E] {
	type Item = E

	with Yield[E]
	fun generate(self: [N]E) = {
		for(0..N) { i => yield(self[i]) }
	}
}

effect Collect[T, E] {
	fun collect { gen with Yield[E] }: T
}

default Collect[unit, unit] {
	fun collect { gen with Yield[unit] }: unit {
		try gen with Yield[unit] { i => }
	}
}
