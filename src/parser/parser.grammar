//

import "../../ast"

//

## RULES

lucu // [dynamic]ast.Definition //
  ->
  -> error      ";" lucu // this = _2                    //
  -> definition ";" lucu // this = _2; append(&this, _0) //
;

definition // ast.Definition //
 -> definition_type // this = _0 //
 -> definition_func // this = _0 //
;

definition_type // ast.Definition //
 -> "type" partial_ident generics_defs "=" data_type_full // this = { _1, _2[:], ast.Definition_Type {}, ast.Definition_Impl { definition_type = _4 } } //
 -> "type" partial_ident generics_defs                    // this = { _1, _2[:], ast.Definition_Type {}, nil                                          } //
;

definition_func // ast.Definition //
 -> "func" partial_ident func_sign body // this = { _1, nil, _2, ast.Definition_Impl { definition_func = _3 } } //
 -> "func" partial_ident func_sign      // this = { _1, nil, _2, nil                                          } //
;

type_sign // ast.Definition_Type //
 ->
;

func_sign // ast.Definition_Func //
 -> "(" params ")"                     // this = { _1[:], nil } //
 -> "(" params ")" "->" data_type_full // this = { _1[:], _4  } //
;

body // ast.Body //
 -> "{" "}"
;

# function parameter
param // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

# function parameters, may end with ","
params // [dynamic]ast.Param //
 ->
 -> param            //            append(&this, _0) //
 -> param "," params // this = _2; append(&this, _0) //
;

# generics of a type or effect
generics_defs // [dynamic]string //
 ->
 -> generic_ident generics_defs // this = _1; append(&this, _0) //
;

# identifier with optional package prefix
ident_package // ast.Ident_Full //
 -> ident                           // this = { "", _0, {} } //
 -> partial_ident "." partial_ident // this = { _0, _2, {} } //
;

# identifier with optional package prefix and generics juxtaposition
ident_full // ast.Ident_Full //
 -> ident_package generics // this = _0; this.generics = _1[:] //
;

# constant values
generics // [dynamic]ast.Generic //
 ->
 -> data_type   generics // this = _1; append(&this, _0) //
 -> int_literal generics // this = _1; append(&this, _0) //
 -> str_literal generics // this = _1; append(&this, _0) //
;

# builtin type prefixes
type_prefixes // [dynamic]ast.Type_Prefix //
 ->
 -> prefix_slice   type_prefixes // this = _1; append(&this, _0) //
 -> prefix_array   type_prefixes // this = _1; append(&this, _0) //
 -> prefix_pointer type_prefixes // this = _1; append(&this, _0) //
;

prefix_slice // ast.Type_Slice //
 -> "[" "]"
;

prefix_array // ast.Type_Array //
 -> "[" int_literal "]" // this = { _1  } //
 ->  "[" ident_full "]" // this = { _1  } //
 ->         "[" "_" "]" // this = { nil } //
;

prefix_pointer // ast.Type_Pointer //
 ->     "^" // this = { false } //
 -> "?" "^" // this = { true  } //
;

# data type without generics
data_type // ast.Type //
 -> type_prefixes ident_package // this = { _0[:], _1  } //
 -> type_prefixes "_"           // this = { _0[:], nil } //
;

# data type with optional generics juxtaposition
data_type_full // ast.Type //
 -> type_prefixes ident_full // this = { _0[:], _1  } //
 -> type_prefixes "_"        // this = { _0[:], nil } //
;

## LEXEMES

ident // string //
 -> generic_ident // this = _0 //
 -> partial_ident // this = _0 //
;

generic_ident // string // ;
partial_ident // string // ;

int_literal // u64 // ;

str_literal // string // ;
