##
# Everything in this file is always in scope
##

type Never = !
type Unit = struct()

##
# Panics with message if the assertion is not met,
# preferred to be used only for debugging.
##
fun assert(all: bool, msg: str) = {
	if all {
	} else { # fails
		panic(msg)
	}
}

##
# yield
##
effect Yield[T] = {
	fun yield(t: T)
}

fun first[T] { body with Yield[T] }: T
with Loc = {
	try {
		body
		panic("nothing was yielded")
	} with Yield[T] {
		t -> break t
	}
}

fun nth[T] { body with Yield[T] }: T
with Loc = {
	mut current: usize = 0
	try {
		body
		panic("not enough was yielded")
	} with Yield[T] {
		t ->
		if current == num {
			break t
		} else {
			do current++
		}
	}
}

fun last[T] { body with Yield[T] }: T
with Loc = {
	let mut current: T = ---
	let mut yielded = false
	try body with Yield[T] {
		t ->
		current = t
		yielded = true
	}
	if yielded {
		current
	} else {
		panic("nothing was yielded")
	}
}

fun for(start usize, end usize) { body(i: usize) } = {
	mut n = start
	loop {
		if n == end {
			break
		} else {
			body(n++)
		}
	}
}

fun while { test: bool } { body } = {
	loop {
		if test {
			body
		} else {
			break
		}
	}
}

fun until { test: bool } { body } = {
	loop {
		if test {
			break
		} else {
			body
		}
	}
}

# TODO: && operator
fun and(a: bool, b: bool): bool = {
	if a {
		b
	} else {
		false
	}
}

##
# Exits the program and displays an error message,
# preferred to be used only for debugging.
##
fun panic(msg: str): !
with Loc = {
	trace("panic: ")
	trace(msg)
	trace("\n")
	trap()
}

##
# Exits the program and displays an error message,
# marks code paths that aren't implemented yet.
##
fun todo(msg: str): !
with Loc = {
	trace("todo: ")
	trace(msg)
	trace("\n")
	trap()
}

fun trap(): !
with Loc = {
	trace("trapped at ")
	trace(LOCATION)
	trace("\n")
	trap_silent()
}

##
# The following functions have internal definitions.
# These are not based on a specific target.
##

##
# Marks that a code path is unreachable.
# This function should NEVER actually be called!
# For displaying an error, &panic is preferred.
##
fun unreachable(): !

##
# Returns the length of a slice.
##
fun len[T](slice: []T): usize

##
# Creates a slice from a pointer and length.
##
fun raw_slice[T](ptr ^T, len usize): []T

##
# Effect to get the location of the call in the source code.
# When used directly, it returns the current line of code.
# When used as an effect parameter inside a function, it returns the location of the caller.
##
effect Loc = {
	const LOCATION: str
}

default Loc

effect Foreign = {
	##
	# Links to a dynamic library using an effect as a foreign interface.
	# &EFFECT SHOULD be annotated with @foreign,
	# as it uses the data inside to determine the symbol names for the effect functions.
	##
	fun link[LIB: str, EFFECT: effect] { body with E }
	fun asm[ASSEMBLY: str, CONSTRAINTS: str, SIDEEFFECTS: bool]
	fun syscall[N: usize](nr: int, args: [N]int): int
}

##
# The following functions may have an internal definition based on the target.
# They also have default implementations for unknown targets.
##

##
# Prints a debug message to the environment (usually the standard error).
# The message is printed exactly as it is, so concatinating strings is possible by calling &trace multiple times.
##
fun trace(msg: str)

##
# Function that ends execution of the entire program.
# The way it ends execution depends on the target.
# 
# For instance, it could:
#  - end the process
#  - run a halt instruction
#  - throw an exception / interrupt
#  - spin forever
##
fun trap_silent(): !
