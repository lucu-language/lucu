##
# everything in this file is always in scope
##

import "io"

##
# crude way of reading and writing data
# defined for the main function
##
effect debug {
	fun putint(n int)
	fun putstr(s str)
	fun wait()
}

@capability
fun debug() debug / io.stdio {
	let in = io.stdin()
	let out = io.stdout()
	handle debug {
		fun putint(n int) {
			with out {
				io.write_int(n)
				io.write("\n");
			}
		}
		fun putstr(s str) {
			with out {
				io.write(cast s);
			}
		}
		fun wait() {
			with in {
				io.skip_line();
			}
		}
	}
}

##
# panics with message if the assertion is not met
# preferred to be used only for debugging
##
fun assert(all bool, msg str) {
	if all {
	} else { # fails
		panic(msg)
	}
}

##
# modulo operator
##
fun mod(dividend int, divisor int) int {
	dividend - ((dividend / divisor) * divisor)
}

##
# implicit break effect
# breaks up to the nearest try block
##
effect break {
	fun break() !
}

handle break fails {
	fun break() ! {
		fail
	}
}

##
# basic ranged for loop
##
fun for(start usize, end usize, fn consume fails) {
	mut n = start
	with fn loop {
		if n == end {
			break()
		} else {
			consume(n++)
		}
	}
}

effect consume {
	fun consume(n usize)
}

##
# exits the program and displays an error message
# preferred to be used only for debugging
##
fun panic(msg str) ! / srcloc {
	trace("panic: ")
	trace(msg)
	trace("\n")
	trap()
}

##
# exits the program and displays an error message
# marks code paths that aren't implemented yet
##
fun todo(msg str) ! / srcloc {
	trace("todo: ")
	trace(msg)
	trace("\n")
	trap()
}

##
# the following functions have internal definitions
# these are not based on a specific target
##

##
# marks that a code path is unreachable
# this function should NEVER actually be called
# for displaying an error, &panic is preferred
##
fun unreachable() ! {
	# internally defined
	loop {}
}

##
# returns the length of a slice
##
fun len(slice []u8) usize {
	# internally defined
	unreachable()
}

##
# effect to get the location of the call in the source code
# has an internally defined global handler
# when used directly, it returns the location of the call to &source_location
# when used as an effect parameter inside a function, it returns the location of the caller
##
effect srcloc {
	fun source_location() str
}

handle srcloc {
	fun source_location() str {
		# internally defined
		unreachable()
	}
}

##
# effect to load dynamic libraries
# a loader is provided for the main function that links libraries at compile-time
##
effect loader {
	##
	# &$effect SHOULD be annotated with @foreign,
	# as it uses the data inside to determine the symbol names for the effect functions
	##
	fun load_into_effect($lib str) handle $effect
}

@capability
fun _linker() loader {
	# internally defined
	unreachable()
}

##
# the following functions may have an internal definition based on the target
# they also have default implementations for unknown targets
##

##
# prints a debug message to the environment (usually the standard error)
# the message is printed exactly as it is, so concatinating strings is possible by calling &trace multiple times
##
fun trace(s str) {
	# internally defined based on target
}

##
# function that ends execution of the entire program
# the way it ends execution depends on the target
# for instance, it could:
#  - end the process
#  - run a halt instruction
#  - throw an exception / interrupt
#  - spin forever
##
fun trap() ! / srcloc {
	# internally defined based on target
	trace("trapped at ")
	trace(source_location())
	trace("\n")
	loop {}
}
