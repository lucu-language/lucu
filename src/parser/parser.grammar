//

import "../../ast"

exprs :: proc(exprs: ..ast.Expression) -> []ast.Expression {
  return slice.clone(exprs)
}

//

## RULES

lucu // [dynamic]ast.Definition //
  ->
  -> error      ";" lucu // this = _2                    //
  -> definition ";" lucu // this = _2; append(&this, _0) //
;

definition // ast.Definition //
 -> definition_type // this = _0 //
 -> definition_func // this = _0 //
;

definition_type // ast.Definition //
 -> "type" partial_ident generics_defs "=" data_type_full // this = { _1, _2[:], ast.Definition_Type {}, ast.Definition_Impl { definition_type = _4 } } //
 -> "type" partial_ident generics_defs                    // this = { _1, _2[:], ast.Definition_Type {}, nil                                          } //
;

definition_func // ast.Definition //
 -> "func" partial_ident func_sign body // this = { _1, nil, _2, ast.Definition_Impl { definition_func = _3 } } //
 -> "func" partial_ident func_sign      // this = { _1, nil, _2, nil                                          } //
;

type_sign // ast.Definition_Type //
 ->
;

func_sign // ast.Definition_Func //
 -> "(" params ")"                     // this = { _1[:], nil } //
 -> "(" params ")" "->" data_type_full // this = { _1[:], _4  } //
;

# function parameter
param // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

# function parameters, may end with ","
params // [dynamic]ast.Param //
 ->
 -> param            //            append(&this, _0) //
 -> param "," params // this = _2; append(&this, _0) //
;

# generics of a type or effect
generics_defs // [dynamic]string //
 ->
 -> generic_ident generics_defs // this = _1; append(&this, _0) //
;

# identifier with optional package prefix
ident_package // ast.Ident_Full //
 -> ident                           // this = { "", _0, {} } //
 -> partial_ident "." partial_ident // this = { _0, _2, {} } //
;

# identifier with optional package prefix and generics juxtaposition
ident_full // ast.Ident_Full //
 -> ident_package generics // this = _0; this.generics = _1[:] //
;

# constant values
generics // [dynamic]ast.Generic //
 ->
 -> data_type   generics // this = _1; append(&this, _0) //
 -> int_literal generics // this = _1; append(&this, _0) //
 -> str_literal generics // this = _1; append(&this, _0) //
;

### TYPE RULES

# builtin type prefixes
type_prefixes // [dynamic]ast.Type_Prefix //
 -> type_prefix               //            append(&this, _0) //
 -> type_prefix type_prefixes // this = _1; append(&this, _0) //
;

type_prefix // ast.Type_Prefix //
 -> prefix_slice   // this = _0 //
 -> prefix_array   // this = _0 //
 -> prefix_pointer // this = _0 //
;

prefix_slice // ast.Type_Slice //
 -> "[" "]"
;

prefix_array // ast.Type_Array //
 -> "[" int_literal "]" // this = { _1  } //
 ->  "[" ident_full "]" // this = { _1  } //
 ->         "[" "_" "]" // this = { nil } //
;

prefix_pointer // ast.Type_Pointer //
 ->     "^" // this = { false } //
 -> "?" "^" // this = { true  } //
;

# struct members
named_member // ast.Param //
 -> partial_ident ":" data_type_full // this = { _0, _2 } //
;

member // ast.Param //
 -> data_type_full // this = { "", _0 } //
 -> named_member   // this = _0         //
;

members // [dynamic]ast.Param //
 ->
 -> member             //            append(&this, _0) //
 -> member "," members // this = _2; append(&this, _0) //
;

struct_members // [dynamic]ast.Param //
 ->
 -> named_member       //            append(&this, _0) //
 -> member "," members // this = _2; append(&this, _0) //
;

# type without prefixes
type_struct // ast.Type_Struct //
 -> "(" struct_members ")" // this = { _1[:] } //
;

type_head // ast.Type //
 -> "_"                    // this = { nil, nil } //
 -> type_struct            // this = { nil, _0  } //
 -> "(" data_type_full ")" // this = _1           //
;

# data type without generics
data_type // ast.Type //
 -> type_prefixes ident_package // this = { _0[:], _1 }                                                         //
 -> type_prefixes type_head     // inject_at(&_0, 0, .._1.prefix); this = { _0[:], _1.head }; delete(_1.prefix) //
 -> ident_package               // this = { nil, _0 }                                                           //
 -> type_head                   // this = _0                                                                    //
;

# data type with optional generics juxtaposition
data_type_full // ast.Type //
 -> type_prefixes ident_full // this = { _0[:], _1 }           //
 -> type_prefixes type_head  // this = _1; this.prefix = _0[:] //
 -> ident_full               // this = { nil, _0 }             //
 -> type_head                // this = _0                      //
;

### EXPRESSION RULES

body // ast.Expression //
 -> "{" exprs_semi "}" // this = { .BODY, {base = _1[:]} } //
;

exprs_semi // [dynamic]ast.Expression //
 ->
 -> expr                //            append(&this, _0) //
 -> expr ";" exprs_semi // this = _2; append(&this, _0) //
;

exprs_comma // [dynamic]ast.Expression //
 ->
 -> expr                 //            append(&this, _0) //
 -> expr "," exprs_comma // this = _2; append(&this, _0) //
;

expr4 // ast.Expression //
 -> body                       // this = _0                                     //
 -> "(" expr ")"               // this = _1                                     //
 -> int_literal                // this = { .INT,   {int   = {nil, _0}} }        //
 -> str_literal                // this = { .STR,   {str   = {nil, _0}} }        //
 -> ident_full                 // this = { .IDENT, {ident = {nil, _0}} }        //
 -> "loop" body                // this = _1; this.kind = .LOOP                  //
 -> "if" expr body             // this = { .IF_ELSE, {base = exprs(_1,_2)   } } //
 -> "if" expr body "else" body // this = { .IF_ELSE, {base = exprs(_1,_2,_4)} } //
 -> "break"                    // this = { .BREAK,   {base = nil            } } //
 -> "break" "(" expr ")"       // this = { .BREAK,   {base = exprs(_2)      } } //
 -> "@sizeof"  data_type_full  // this = { .SIZE_OF,  {sizeof  = {nil, _1}} }   //
 -> "@alignof" data_type_full  // this = { .ALIGN_OF, {alignof = {nil, _1}} }   //
 -> "[" exprs_comma "]"        // this = { .ARRAY, {base = _1[:]} }             //
 -> "---"                      // this = { .UNINIT, {} }                        //
;

expr3 // ast.Expression //
 -> expr3 "--" // this = { .UNARY_OP, {unnop = {exprs(_0), .POST_DECREMENT}} } //
 -> expr3 "++" // this = { .UNARY_OP, {unnop = {exprs(_0), .POST_INCREMENT}} } //
 -> expr4      // this = _0                                                    //
;

expr2 // ast.Expression //
 -> "cast" expr2 // this = { .UNARY_OP, {unnop = {exprs(_1), .CAST}} } //
 -> expr3        // this = _0                                          //
;

expr1 // ast.Expression //
 -> expr1 "as" data_type_full // this = { .AS, {as = {exprs(_0), _2}} } //
 -> expr2                     // this = _0                              //
;

expr0 // ast.Expression //
 -> "let" partial_ident ":" data_type_full "=" expr0 // this = { .LET, {let = { exprs({ .AS, {as = {exprs(_5), _3}} }), _1, false }} } //
 -> "let" partial_ident                    "=" expr0 // this = { .LET, {let = { exprs(                         _3    ), _1, false }} } //
 -> "do" expr0                                       // this = { .UNARY_OP, {unnop = {exprs(_1), .DO  }} }                             //
 -> expr1                                            // this = _0                                                                      //
;

expr // ast.Expression //
 -> expr0 // this = _0 //
;

## LEXEMES

ident // string //
 -> generic_ident // this = _0 //
 -> partial_ident // this = _0 //
;

generic_ident // string // ;
partial_ident // string // ;

int_literal // u64 // ;

str_literal // string // ;
