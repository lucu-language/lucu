# we import 'io' from the core library to interact with the console
import "core:io"

# we define an effect for interacting with a buffer
effect buf(`item) {
	fun push(elem `item) usize
	fun get(index usize) const `item

	# the 'iter' effect is defined within the preamble
	fun iter() impl iter(const `item)
}

# default implementation for unit buffer
impl buf(unit) {
	fun push(elem unit) usize { 0 }
	fun get(index usize) unit { 0 }
	fun iter() impl iter(unit) {
		move {}
	}
}

# implementation of these effects using a constant sized array
fun array_buffer(`cap usize) impl buf(`item) {
	mut array [`cap]const `item = 0
	mut size  usize             = 0
	impl buf(`item) move {
		fun push(elem `item) usize {
			array[size] = elem
			size++
		}
		fun get(index usize) const `item {
			array[index]
		}
		fun iter() impl iter(const `item) {
			mut current usize = 0
			move {
				if current < size {
					array[current++]
				} else {
					no_such_element()
				}
			}
		}
	}
}

# example of using a string buffer
# the 'io.stdio' effect allows use of the 'io.println' function
fun main() / io.stdio {

	let buffer impl buf(str) = array_buffer(16)

	# a 'with' block puts the effect handler in scope
	# which allows us to use the defined effect functions
	with buffer {

		# we push some elements
		do push("Hello")
		do push("world")

		# we print all elements
		# 'for' is just a function defined within the preamble!
		for(iter() as impl iter(const str)) {
			elem ->
			io.putstr(elem)
		}

	}

}
