typechecking todo:
- fail type in handlers
- fail type of implicit handlers/naked handler calls (and only allowed in try blocks if they fail!)
- functions must not be (mutually) recursive through try blocks
- use global GenericIdx and global AssocIdx instead of the wacky stuff we have right now

parser todo:
- operator precedence

todo:
- !!! deallocate stuff in loops
- unbounded ranges
- fail in try blocks
- error if core library not found
- effect associated types
- effect associated handlers
- dynamic effects (less powerfull, but are ONE type for every handler)
- anonymous effects (are always dynamic)

# `t can be moved
effect auto move(`t) {}

# `t has a compile-time size
effect auto sized(`t) {
	const SIZE usize
}

# `t can be 0-initialized (zeroed out is a valid value)
effect auto zeroinit(`t) {}

# `t can be left uninitialized (any byte combination is a valid value)
effect auto uninit(`t) {}

effect auto pointee(`t) {
	type metadata
}

effect deref(`t) {
	type target
	fun deref(t `t) ^target ref t
}

effect clone_ref(`t) {
	fun clone_ref(t `t) `t ref t
}

effect clone(`t) {
	fun clone(t `t) `t
}

effect copy(`t) {
	handle clone_ref(`t)
}

effect drop(`t) {
	fun _drop(mut t `t)
}

fun drop(t `t) {}

fun choose(b bool, t `t, f `t) `t ref t, f {
	if b {
		t
	} else {
		f
	}
}

effect buf(`elem) {
	type key
	type key_range

	handle sized(key)
	handle sized(key_range)
	handle move(key)
	handle move(key_range)
	handle copy(key)
	handle copy(key_range)

	fun push(sink e `elem) key
	fun get(i key) ^`elem ref i

	fun push_range(sink es []`elem) key_range
	fun get_range(is key_range) ^[]`elem ref i
}

effect alloc {
	type box(`t)
		with move(`t)

	handle sized(box(`t))
	handle move(box(`t))
	handle deref(box(`t))
		with target = `t

	fun new(sink t `t) box(`t)
}

handle clone(box(`t))
	with clone(`t) 
	with alloc
{
	fun clone(b box(`t)) box(`t) {
		new(clone(b^))
	}
}

fun arena_alloc() handle alloc with buf(u8) {
	handle alloc {
		type box(`t) = owned(`t)

		fun new(sink t `t) box(`t) {
			# TODO: alignment padding

			let raw = unsafe_raw(&t)
			let range = push_range(raw.bytes^)
			unsafe_owned(unsafe_cast(get(range), raw.meta))
			forget(t)
		}
	}
}

fun unsafe_raw(t ^`t) struct(bytes ^[]u8, meta metadata) ref t
	with pointee(`t)
{
	internal()
}

fun unsafe_cast(u ^`u, m metadata) ^`t ref u, m
	with pointee(`t)
{
	internal()
}

fun unsafe_owned(t ^`t) owned(t) {
	internal()
}

would be nice:
- tokenizer matches brackets
- seperate token from data
- custom anchor tokens per Parse instance

working on:
- separate generation code from data types
- analyzer gives semantic IR
- try blocks no longer their own function
- reference parameters / outputs
