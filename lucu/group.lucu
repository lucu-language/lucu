## DEFINITION MAGMA ##

effect Magma 't {
	func binop(lhs: 't, rhs: 't) -> 't
}

## ORDERING PROPERTIES ##

(Magma 't) =>
effect Associative 't {}
(Magma 't) =>
effect Commutative 't {}

## IDENTITY PROPERTIES ##

(Magma 't) =>
effect LeftIdentity 't {
	const LEFT_IDENTITY: 't
}
(Magma 't) =>
effect RightIdentity 't {
	const RIGHT_IDENTITY: 't
}

(Magma 't) =>
effect Identity 't {
	const IDENTITY: 't
}
(Identity 't) => {
	handle  LeftIdentity 't { const  LEFT_IDENTITY = IDENTITY }
	handle RightIdentity 't { const RIGHT_IDENTITY = IDENTITY }
}

## CANCELLATION PROPERTIES ##

# -= cancellation property =-
#  for any identity (a * x = b),
#  x is unique

# -= division property =-
#  for any a, b,
#  the identity (a * x = b) exists
#  x is unique

(Magma 't) =>
effect LeftCancellation 't {
	##
	# Calculates x in the identity (a * x = b)
	##
	func left_cancel(a: 't, b: 't) -> 't
}
(Magma 't) =>
effect RightCancellation 't {
	##
	# Calculates x in the identity (x * a = b)
	##
	func right_cancel(a: 't, b: 't) -> 't
}

(Commutative 't) =>
effect Cancellation 't {
	##
	# Calculates x in the identity (a * x = b)
	##
	func cancel(a: 't, b: 't) -> 't
}
(Cancellation 't) => {
	handle  LeftCancellation 't { a, b -> cancel(a, b) }
	handle RightCancellation 't { a, b -> cancel(a, b) }
}

( LeftCancellation 't) => effect  LeftDivision 't {}
(RightCancellation 't) => effect RightDivision 't {}
(     Cancellation 't) => effect      Division 't {}

effect TwoSidedCancellation 't = (LeftCancellation 't, RightCancellation 't)
effect TwoSidedDivision     't = (LeftDivision     't, RightDivision     't)

## INVERTIBLE PROPERTIES ##

effect  LeftInvertible 't = ( LeftIdentity 't,     LeftDivision 't)
effect RightInvertible 't = (RightIdentity 't,    RightDivision 't)
effect      Invertible 't = (     Identity 't, TwoSidedDivision 't)

(LeftInvertible 't) =>
func left_inverse(a: 't) -> 't { left_cancel(a, LEFT_IDENTITY) }

(RightInvertible 't) =>
func right_inverse(a: 't) -> 't { right_cancel(a, RIGHT_IDENTITY) }

(Invertible 't) =>
func inverse(a: 't) -> 't { left_cancel(a, IDENTITY) }

## COMBINED PROPERTIES ##

effect  Semigroup 't = Associative 't
effect Quasigroup 't = TwoSidedDivision 't
effect       Loop 't = (Quasigroup 't, Identity 't)
effect     Monoid 't = (Semigroup 't, Identity 't)
effect      Group 't = (Semigroup 't, Invertible 't)

## GROUP DEFINITIONS ##

func monoid(
	binop:    func (lhs: 't, rhs: 't) -> 't,
	identity: 't,
	body:     Body (monoid 't) 'r,
) -> 'r {
	handle Magma       't { lhs, rhs -> binop(lhs, rhs) }
	handle Identity    't { const IDENTITY = identity   }
	handle Associative 't {}
	body.()
}

func group(
	binop:    func (lhs: 't, rhs: 't) -> 't,
	identity: 't,
	inverse:  func (a: 't),
	body:     Body (group 't) 'r,
) -> 'r {
	using monoid(binop, identity, inverse)

	handle  LeftCancellation 't { a, b -> binop(inverse(a), b) }
	handle RightCancellation 't { a, b -> binop(b, inverse(a)) }
	handle  LeftDivision 't {}
	handle RightDivision 't {}

	body.()
}

(Infix 't "+" 't, Output = 't) =>
effect Sum 't {
	func sum(body: Body (monoid 't) 'r) -> 'r
}

(Infix 't "*" 't, Output = 't) =>
effect Product 't {
	func product(body: Body (monoid 't) 'r) -> 'r
}

(Infix 't "+" 't, Output = 't) =>
effect Addititive 't {
	func addditive(body: Body (group 't) 'r) -> 'r
}

(Infix 't "*" 't, Output = 't) =>
effect Multiplicative 't {
	func multiplicative(body: Body (group 't) 'r) -> 'r
}

(Num    't) =>
handle            Sum 't { body -> monoid({ lhs, rhs -> lhs + rhs }, 0, body) }
(Num    't) =>
handle        Product 't { body -> monoid({ lhs, rhs -> lhs * rhs }, 1, body) }
(Signed 't) =>
handle       Additive 't { body -> group({ lhs, rhs -> lhs + rhs }, 0, { a ->    -a }, body) }
(Float  't) =>
handle Multiplicative 't { body -> group({ lhs, rhs -> lhs * rhs }, 1, { a -> 1 / a }, body) }
