##
# everything in this file is always in scope
##

##
# panics with message if the assertion is not met
# preferred to be used only for debugging
##
fun assert(all bool, msg str) {
	if all {
	} else { # fails
		panic(msg)
	}
}

##
# modulo operator
##
fun mod(dividend int, divisor int) int {
	dividend - ((dividend / divisor) * divisor)
}

##
# error effects
##
effect no_such_element(`t) {
	fun no_such_element() `t
}

effect fail {
	fun fail() !
}

##
# sink
##
effect sink(`t) {
	fun push(t `t)
}

fun push_slice(buf []`t) / sink(`t) {
	for(iter_slice(buf)) { t -> push(t) }
}

fun sink_slice(mut buf []const `e) impl sink(`e) / fail {
	mut n usize = 0
	move {
		t ->
		if n == len(buf) {
			fail()
		} else {
			buf[n++] = t
		}
	}
}

fun sink_buffer() impl sink(`t) / buf(`t) {
	{ t -> buf_push(t) }
}

##
# buffer
##
effect buf(`t) {
	fun buf_push(t `t)
	fun buf_len() usize
	fun buf_slice() []const `t
}

fun buf_push_slice(buf []`t) / buf(`t) {
	for(iter_slice(buf)) { t -> buf_push(t) }
}

fun buffer_slice(mut buf[]const `t) impl buf(`t) / fail {
	mut n usize = 0
	impl buf(`t) move {
		fun buf_push(t `t) {
			if n == len(buf) {
				fail()
			} else {
				buf[n++] = t
			}
		}
		fun buf_len() usize {
			n
		}
		fun buf_slice() []const `t {
			buf[0..n]
		}
	}
}

##
# iterator
##
effect iter(`t) {
	fun next() `t / no_such_element(`t)
}

fun iter_slice(buf []`e) impl iter(const `e) {
	mut n usize = 0
	move {
		if n == len(buf) {
			no_such_element()
		} else {
			buf[n++]
		}
	}
}

fun range(start usize, end usize) impl iter(usize) {
	mut n = start
	move {
		if n == end {
			no_such_element()
		} else {
			n++
		}
	}
}

fun from(start usize) impl iter(usize) {
	mut n = start
	move { n++ }
}

##
# basic for loop
##
fun for(it impl iter(`e), fn impl consume(`e)) {
	let on_nse impl no_such_element(`e) -> unit = { break }
	try with on_nse, it, fn loop {
		consume(next() as `e)
	}
}

effect iterable(`t, `e) {
	fun iter(t `t) impl iter(`e)
}

impl iterable([]`t, const `t) {
	fun iter(t []`t) impl iter(const `t) {
		iter_slice(t)
	}
}

fun foreach(t `t, fn impl consume(`e)) / iterable(`t, `e) {
	let iter = iter(t) as impl iter(`e)
	for(iter, fn)
}

##
# while loop
##
fun while(cond impl test, fn impl perform) {
	try with fn loop {
		if test() with cond {
			perform()
		} else {
			break
		}
	}
}

##
# until loop
##
fun until(cond impl test, fn impl perform) {
	try with fn loop {
		if test() with cond {
			break
		} else {
			perform()
		}
	}
}

##
# run
##
fun run(fn impl supply(`t)) `t {
	with fn {
		supply()
	}
}

##
# repeat loop
##
fun repeat(fn impl perform -> `t) `t {
	try with fn loop {
		perform()
	}
}

effect consume(`t) {
	fun consume(t `t)
}

effect test {
	fun test() bool
}

effect perform {
	fun perform()
}

effect supply(`t) {
	fun supply() `t
}

# TODO: && operator
fun and(a bool, b bool) bool {
	if a {
		b
	} else {
		false
	}
}

##
# exits the program and displays an error message
# preferred to be used only for debugging
##
fun panic(msg str) ! / srcloc {
	trace("panic: ")
	trace(msg)
	trace("\n")
	trap()
}

fun trap() ! / srcloc {
	trace("trapped at ")
	trace(source_location())
	trace("\n")
	trap_silent()
}

##
# exits the program and displays an error message
# marks code paths that aren't implemented yet
##
fun todo(msg str) ! / srcloc {
	trace("todo: ")
	trace(msg)
	trace("\n")
	trap()
}

fun internal() `t / srcloc {
	compile_error("internal function has no definition on specified target")
}

##
# the following functions have internal definitions
# these are not based on a specific target
##

fun compile_error(`msg str) ! / srcloc {
	internal()
}

##
# marks that a code path is unreachable
# this function should NEVER actually be called
# for displaying an error, &panic is preferred
##
fun unreachable() ! {
	internal()
}

##
# returns the length of a slice
##
fun len(slice []`elem) usize {
	internal()
}

##
# effect to get the location of the call in the source code
# has an internally defined global handler
# when used directly, it returns the location of the call to &source_location
# when used as an effect parameter inside a function, it returns the location of the caller
##
effect srcloc {
	fun source_location() str
}

impl srcloc {
	fun source_location() str {
		internal()
	}
}

##
# links to a dynamic library using an effect as a foreign interface
# &`effect MUST be annotated with @foreign,
# as it uses the data inside to determine the symbol names for the effect functions
##
effect foreign {
	fun impl_link(`lib str) impl `effect
	fun impl_asm(`assembly str, `constraints str, `sideeffects bool) impl `effect
	fun syscall(nr int, args [`N]int) int
}

##
# the following functions may have an internal definition based on the target
# they also have default implementations for unknown targets
##

##
# prints a debug message to the environment (usually the standard error)
# the message is printed exactly as it is, so concatinating strings is possible by calling &trace multiple times
##
fun trace(s str) {
	internal()
}

##
# function that ends execution of the entire program
# the way it ends execution depends on the target
# for instance, it could:
#  - end the process
#  - run a halt instruction
#  - throw an exception / interrupt
#  - spin forever
##
fun trap_silent() ! {
	internal()
}
